#include "main.h"

//VESC vesc;

void initPath()
{
    //
    // Code generated by G Shadow Robot Master
    //
    points[0] = (pointInfo){.targetPos.x = 0, .targetPos.y = 0, .targetPos.w = 0,.tolerance.x = 0.05, .tolerance.y = 0.05, .tolerance.w = 0.1,.maxSpeed.x = 2, .maxSpeed.y = 2, .maxSpeed.w = 1, .pidOn = true , .command = noAction};
    points[1] = (pointInfo){.targetPos.x = 0.77, .targetPos.y = 0, .targetPos.w = 0,.tolerance.x = 0.05, .tolerance.y = 0.05, .tolerance.w = 0.1,.maxSpeed.x = 2, .maxSpeed.y = 2, .maxSpeed.w = 1, .pidOn = true, .command = VESC};
    points[2] = (pointInfo){.targetPos.x = 0.77, .targetPos.y = 1.4, .targetPos.w = 0,.tolerance.x = 0.05, .tolerance.y = 0.05, .tolerance.w = 0.1,.maxSpeed.x = 2, .maxSpeed.y = 2, .maxSpeed.w = 1, .pidOn = true, .command = homing};
    points[3] = (pointInfo){.targetPos.x = 2.2, .targetPos.y = 1.4, .targetPos.w = 0,.tolerance.x = 0.05, .tolerance.y = 0.05, .tolerance.w = 0.1,.maxSpeed.x = 1.5, .maxSpeed.y = 1.5, .maxSpeed.w = 1, .pidOn = true, .command = fire};
    points[4] = (pointInfo){.targetPos.x = 2.25, .targetPos.y = 0, .targetPos.w = 0,.tolerance.x = 0.05, .tolerance.y = 0.05, .tolerance.w = 0.1,.maxSpeed.x = 1.5, .maxSpeed.y = 1.5, .maxSpeed.w = 1, .pidOn = true, .command = readyPosition};
    points[5] = (pointInfo){.targetPos.x = 3.76, .targetPos.y = 0, .targetPos.w = 0,.tolerance.x = 0.05, .tolerance.y = 0.05, .tolerance.w = 0.1,.maxSpeed.x = 2, .maxSpeed.y = 2, .maxSpeed.w = 1, .pidOn = true, .command = homing};
    points[6] = (pointInfo){.targetPos.x = 3.76, .targetPos.y = 1.4, .targetPos.w = 0,.tolerance.x = 0.05, .tolerance.y = 0.05, .tolerance.w = 0.1,.maxSpeed.x = 2, .maxSpeed.y = 2, .maxSpeed.w = 1, .pidOn = true , .command = fire};
    points[7] = (pointInfo){.targetPos.x = 5.23, .targetPos.y = 1.4, .targetPos.w = 0,.tolerance.x = 0.05, .tolerance.y = 0.05, .tolerance.w = 0.1,.maxSpeed.x = 1.5, .maxSpeed.y = 1.5, .maxSpeed.w = 1, .pidOn = true , .command = readyPosition};
    points[8] = (pointInfo){.targetPos.x = 5.23, .targetPos.y = 0.722, .targetPos.w = 0,.tolerance.x = 0.03, .tolerance.y = 0.03, .tolerance.w = 0.1,.maxSpeed.x = 1.5, .maxSpeed.y = 1.5, .maxSpeed.w = 1, .pidOn = true, .command = noAction};
    points[9] = (pointInfo){.targetPos.x = 8.44, .targetPos.y = 0.722, .targetPos.w = 0,.tolerance.x = 0.05, .tolerance.y = 0.05, .tolerance.w = 0.1,.maxSpeed.x = 2, .maxSpeed.y = 2, .maxSpeed.w = 1, .pidOn = true, .command = noAction};
    points[10] = (pointInfo){.targetPos.x = 8.44, .targetPos.y = 4.7, .targetPos.w = 90,.tolerance.x = 0.05, .tolerance.y = 0.05, .tolerance.w = 0.1,.maxSpeed.x = 2, .maxSpeed.y = 2, .maxSpeed.w = 1, .pidOn = true, .command = noAction};
    points[11] = (pointInfo){.targetPos.x = 7.8, .targetPos.y = 4.7, .targetPos.w = 90,.tolerance.x = 0.01, .tolerance.y = 0.01, .tolerance.w = 0.1,.maxSpeed.x = 1, .maxSpeed.y = 1, .maxSpeed.w = 1, .pidOn = true, .command = noAction};
    points[12] = (pointInfo){.targetPos.x = 8, .targetPos.y = 2.83, .targetPos.w = 90,.tolerance.x = 0.05, .tolerance.y = 0.05, .tolerance.w = 0.1,.maxSpeed.x = 2, .maxSpeed.y = 2, .maxSpeed.w = 1, .pidOn = true, .command = noAction};
    points[13] = (pointInfo){.targetPos.x = 4.6, .targetPos.y = 2.83, .targetPos.w = 90,.tolerance.x = 0.05, .tolerance.y = 0.05, .tolerance.w = 0.1,.maxSpeed.x = 2, .maxSpeed.y = 2, .maxSpeed.w = 1, .pidOn = true, .command = noAction};
    points[14] = (pointInfo){.targetPos.x = 4.02, .targetPos.y = 3.363, .targetPos.w = 134.63,.tolerance.x = 0.01, .tolerance.y = 0.01, .tolerance.w = 0.1,.maxSpeed.x = 1, .maxSpeed.y = 1, .maxSpeed.w = 1, .pidOn = true, .command = noAction};
    //
    // Code generated by G Shadow Robot Master
    //
}

void inverse(float vx, float vy, float w)
{
    motor1 = int((1 / wheelR) * (vx - vy - (lx + ly) * w) * radian_to_rpm_convert);
    motor2 = int((1 / wheelR) * (vx + vy + (lx + ly) * w) * radian_to_rpm_convert);
    motor3 = int((1 / wheelR) * (vx + vy - (lx + ly) * w) * radian_to_rpm_convert);
    motor4 = int((1 / wheelR) * (vx - vy + (lx + ly) * w) * radian_to_rpm_convert);
}

void motorUpdate()
{
    
    motor.update(motor1, motor2, motor3, motor4);
    // PS4 function
    checkFlatLoop();
}

void odomUpdate()
{
    if(targetPoint == maxPointCount)
        return;
        
    // Go to next point
    if (((fabs(targetPos.x - curPos.x)) < tolerance.x) && ((fabs(targetPos.y - curPos.y)) < tolerance.y) && ((fabs(targetPos.w - curPos.w)) < tolerance.w))
    {
        switch(command)
        {
            case noAction:
                break;
            case homing:
                slave.homing();
                break;
            case readyPosition:
                slave.readyPosition();
                break;
            case fire:
                slave.fire();
                break;
            case estop:
                slave.estop();
                break;
            case VESC:
                slave.vesc();
                break;
            case grasp:
                slave.grasp();
        }
        
        
        targetPoint = ++targetPoint;

        tolerance.x = points[targetPoint].tolerance.x;
        tolerance.y = points[targetPoint].tolerance.x;
        tolerance.w = points[targetPoint].tolerance.x;

        targetPos.x = points[targetPoint].targetPos.x;              //+    startup_offset_x_encoder;
        targetPos.y = points[targetPoint].targetPos.y;              //+    startup_offset_y_encoder;
        targetPos.w = points[targetPoint].targetPos.w * DEG_TO_RAD; //-    startup_offset_w_encoder;

        pidOn = points[targetPoint].pidOn;
        command = points[targetPoint].command;

        maxSpeed.x = points[targetPoint].maxSpeed.x;
        maxSpeed.y = points[targetPoint].maxSpeed.y;
        maxSpeed.w = points[targetPoint].maxSpeed.w;

        inverse(0, 0, 0);
        return;
    }

    struct position error = {.x = targetPos.x - curPos.x, .y = targetPos.y - curPos.y, .w = targetPos.w - curPos.w};
    if (pidOn)
    {
        localVelocity.x = (fabs(error.x) > tolerance.x) ? constrain((PID_P.x * (error.x) + PID_D.x * (error.x - lastError.x)), -maxSpeed.x, maxSpeed.x) : 0;
        localVelocity.y = (fabs(error.y) > tolerance.y) ? constrain((PID_P.y * (error.y) + PID_D.y * (error.y - lastError.y)), -maxSpeed.y, maxSpeed.y) : 0;
        localVelocity.w = (fabs(error.w) > tolerance.w) ? constrain((PID_P.w * (error.w) + PID_D.w * (error.w - lastError.w)), -maxSpeed.w, maxSpeed.w) : 0;
        
    }
    else
    {
        localVelocity.x = (fabs(error.x) > tolerance.x) ? constrain((copysign(maxSpeed.x, (error.x))), -maxSpeed.x, maxSpeed.x) : 0;
        localVelocity.y = (fabs(error.y) > tolerance.y) ? constrain((copysign(maxSpeed.y, (error.y))), -maxSpeed.y, maxSpeed.y) : 0;
        localVelocity.w = (fabs(error.w) > tolerance.w) ? constrain((copysign(maxSpeed.w, (error.w))), -maxSpeed.w, maxSpeed.w) : 0;
    }
    lastError.x = error.x;
    lastError.y = error.y;
    lastError.w = error.w;

    globalVelocity.x = localVelocity.x * cos(-curPos.w) - localVelocity.y * sin(-curPos.w);
    globalVelocity.y = localVelocity.x * sin(-curPos.w) + localVelocity.y * cos(-curPos.w); //local to global transformation   (angle only)

    inverse(globalVelocity.x, globalVelocity.y, localVelocity.w);
}

float map(float in, float inMin, float inMax, float outMin, float outMax)
{
    // check it's within the range
    if (inMin < inMax)
    {
        if (in <= inMin)
            return outMin;
        if (in >= inMax)
            return outMax;
    }
    else
    { // cope with input range being backwards.
        if (in >= inMin)
            return outMin;
        if (in <= inMax)
            return outMax;
    }
    // calculate how far into the range we are
    float scale = (in - inMin) / (inMax - inMin);
    // calculate the output.
    return outMin + scale * (outMax - outMin);
}

void high_func_LH()
{
    if (!autoMode)
    {
        if (((joy_range_mid - joy_range) < getLY()) and (getLY() < (joy_range_mid + joy_range)))
        {
            vt = 0;
        }
        else
        {
            //vt = map(getLY(),0,255,-1,1) * linear_speed ;
            float temp = map(getLY(), 0, 255, -1, 1);
            if (temp < 0)
            {
                vt = (temp * temp) * -1 * linear_speed;
            }
            else
            {
                vt = (temp * temp) * linear_speed;
            }
        }

        if (((joy_range_mid - joy_range) < getLX()) and (getLX() < (joy_range_mid + joy_range)))
        {
            vnt = 0;
        }
        else
        {
            //vnt = map(getLX(),0,255,-1,1) * linear_speed ;
            float temp = map(getLX(), 0, 255, -1, 1);
            if (temp < 0)
            {
                vnt = (temp * temp) * -1 * linear_speed;
            }
            else
            {
                vnt = (temp * temp) * linear_speed;
            }
        }
    }
}
void high_func_RH()
{
    if (!autoMode)
    {
        if (((joy_range_mid - joy_range) < getRX()) and (getRX() < (joy_range_mid + joy_range)))
        {
            wt = 0;
        }
        else
        {
            //wt = map(getRX(),0,255,-1,1) * angular_speed ;
            float temp = map(getRX(), 0, 255, -1, 1);
            if (temp < 0)
            {
                wt = (temp * temp) * -1 * angular_speed;
            }
            else
            {
                wt = (temp * temp) * angular_speed;
            }
        }
    }
}
void high_func_CommandChange() {}
void high_func_L2() {}
void high_func_R2() {}
void high_func_TRI() 
{
    // if the button blocked for 2000 ms or the button press for first time
    if(buttonBlock.read_ms() >= blockTime || firstPress)
    {
        firstPress = false;
        // Stop the timer
        buttonBlock.stop();
        // Send messege to slave
        slave.vesc();
        // Restart the timer
        buttonBlock.reset();
        buttonBlock.start();
    }
}
void high_func_CIR() 
{
    // if the button blocked for 2000 ms or the button press for first time
    if(buttonBlock.read_ms() >= blockTime || firstPress)
    {
        firstPress = false;
        // Stop the timer
        buttonBlock.stop();
        // Send messege to slave
        slave.fire();
        // Restart the timer
        buttonBlock.reset();
        buttonBlock.start();
    }
}
void high_func_CRO() 
{
    // if the button blocked for 2000 ms or the button press for first time
    if(buttonBlock.read_ms() >= blockTime || firstPress)
    {
        firstPress = false;
        // Stop the timer
        buttonBlock.stop();
        // Send messege to slave
        slave.charge();
        // Restart the timer
        buttonBlock.reset();
        buttonBlock.start();
    }
}
void high_func_SQU() 
{
    // if the button blocked for 2000 ms or the button press for first time
    if(buttonBlock.read_ms() >= blockTime || firstPress)
    {
        firstPress = false;
        // Stop the timer
        buttonBlock.stop();
        // Send messege to slave
        slave.homing();
        // Restart the timer
        buttonBlock.reset();
        buttonBlock.start();
    }
}
void high_func_UP() 
{
    // if the button blocked for 2000 ms or the button press for first time
    if(buttonBlock.read_ms() >= blockTime || firstPress)
    {
        firstPress = false;
        // Stop the timer
        buttonBlock.stop();
        // Send messege to slave
        slave.toggleVG();
        // Restart the timer
        buttonBlock.reset();
        buttonBlock.start();
    }    
}
void high_func_RIGHT() 
{
    // if the button blocked for 2000 ms or the button press for first time
    if(buttonBlock.read_ms() >= blockTime || firstPress)
    {
        firstPress = false;
        // Stop the timer
        buttonBlock.stop();
        // Send messege to slave
        slave.toggleHG();
        // Restart the timer
        buttonBlock.reset();
        buttonBlock.start();
    }    
}
void high_func_DOWN() 
{
    // if the button blocked for 2000 ms or the button press for first time
    if(buttonBlock.read_ms() >= blockTime || firstPress)
    {
        firstPress = false;
        // Stop the timer
        buttonBlock.stop();
        // Send messege to slave
        slave.toggleVS();
        // Restart the timer
        buttonBlock.reset();
        buttonBlock.start();
    }    
}
void high_func_LEFT() 
{
        // if the button blocked for 2000 ms or the button press for first time
    if(buttonBlock.read_ms() >= blockTime || firstPress)
    {
        firstPress = false;
        // Stop the timer
        buttonBlock.stop();
        // Send messege to slave
        slave.toggleHS();
        // Restart the timer
        buttonBlock.reset();
        buttonBlock.start();
    }    

}
void high_func_L1()
{
    if (!autoMode)
    {
        autoMode = true;
        motorUpdateTicker.attach(&motorUpdate, UPDATE_RATE);
    }
}
void high_func_L3() {}
void high_func_R1()
{
    if (autoMode)
    {
        autoMode = false;
        motorUpdateTicker.detach();
        motor.manual(); //This changes the acceleration to 99999;
    }
}
void high_func_R3() {}
void high_func_SHARE() 
{
    
}
void high_func_OPTIONS() {}
void low_func_CommandChange() {}
void low_func_LH()
{
    if (!autoMode)
    {
        vt = 0;
        vnt = 0;
    }
}
void low_func_RH()
{
    if (!autoMode)
    {
        wt = 0;
    }
}
void low_func_L2() {}
void low_func_R2() {}
void low_func_TRI() {}
void low_func_CIR() {}
void low_func_CRO() {}
void low_func_SQU() {}
void low_func_UP() {}
void low_func_RIGHT() {}
void low_func_DOWN() {}
void low_func_LEFT() {}
void low_func_L1() {}
void low_func_L3() {}
void low_func_R1() {}
void low_func_R3() {}
void low_func_SHARE() {}
void low_func_OPTIONS() {}
void fall_func_CommandChange() {}
void fall_func_LH()
{
    if (!autoMode)
    {
        vt = 0;
        vnt = 0;
    }
}
void fall_func_RH()
{
    if (!autoMode)
    {
        wt = 0;
    }
}
void fall_func_L2() {}
void fall_func_R2() {}
void fall_func_TRI() {}
void fall_func_CIR() {}
void fall_func_CRO() {}
void fall_func_SQU() {}
void fall_func_UP() {}
void fall_func_RIGHT() {}
void fall_func_DOWN() {}
void fall_func_LEFT() {}
void fall_func_R1()
{
    if (autoMode)
    {
        autoMode = false;
        motorUpdateTicker.detach();
    }
}
void fall_func_L3() {}
void fall_func_L1()
{
    if (!autoMode)
    {
        autoMode = true;
        motorUpdateTicker.attach(&motorUpdate, UPDATE_RATE);
    }
}
void fall_func_R3() {}
void fall_func_SHARE() {}
void fall_func_OPTIONS() {}
void rise_func_CommandChange() {}
void rise_func_LH() {}
void rise_func_RH() {}
void rise_func_L2() {}
void rise_func_R2() {}
void rise_func_TRI() {}
void rise_func_CIR() {}
void rise_func_CRO() {}
void rise_func_SQU() {}
void rise_func_UP() {}
void rise_func_RIGHT() {}
void rise_func_DOWN() {}
void rise_func_LEFT() {}
void rise_func_L1() {}
void rise_func_L3()
{
    if (!autoMode)
    {
        vt = 0;
        vnt = 0;
    }
}
void rise_func_R1() {}
void rise_func_R3()
{
    if (!autoMode)
    {
        wt = 0;
    }
}
void rise_func_SHARE() {}
void rise_func_OPTIONS() {}

// Debug class
char buffer[64];
int accessPoint = 0;
/*
void debugCommand()
{
    fgets(buffer, 64, stdin);
    switch(buffer[0])
    {
        // PID
        // PID_P x
        case 'a':
            PID_P.x = atof(&buffer[2]);
            break;
            
        // PID_P y
        case 'b':
            PID_P.y = atof(&buffer[2]);
            break;
            
        // PID_P w
        case 'c':
            PID_P.w = atof(&buffer[2]);
            break;
            
        // PID_D x
        case 'd':
            PID_I.x = atof(&buffer[2]);
            break;
            
        // PID_D y
        case 'e':
            PID_I.y = atof(&buffer[2]);
            break;
    
        // PID_D w
        case 'f':
            PID_I.w = atof(&buffer[2]);
            break;
        
        // PID_I x
        case 'g':
            PID_D.x = atof(&buffer[2]);
            break;
        
        // PID_I y
        case 'h':
            PID_D.y = atof(&buffer[2]);
            break;
    
        // PID_I w
        case 'i':
            PID_D.w = atof(&buffer[2]);
            break;
            
        // Print PID
        case 'j':
            pc.printPID(PID_P, PID_I, PID_D);
            break;
        
        // Get path
        case 'p':
            pc.printPath(points, maxPointCount);
            break;
            
        // reset
        case 'r':
            targetPoint = 0;
            tolerance.x = points[targetPoint].tolerance.x;
            tolerance.y = points[targetPoint].tolerance.y;
            tolerance.w = points[targetPoint].tolerance.w;
            targetPos.x = points[targetPoint].targetPos.x;              //+    startup_offset_x_encoder;
            targetPos.y = points[targetPoint].targetPos.y;              //+    startup_offset_y_encoder;
            targetPos.w = points[targetPoint].targetPos.w * DEG_TO_RAD; //-    startup_offset_w_encoder;
            pidOn = points[targetPoint].pidOn;
            maxSpeed.x = points[targetPoint].maxSpeed.x;
            maxSpeed.y = points[targetPoint].maxSpeed.y;
            maxSpeed.w = points[targetPoint].maxSpeed.w;
            break;
            
        // set Path
        // Current point
        case 'A':
            accessPoint = atoi(&buffer[2]);
            maxPointCount = accessPoint + 1;
            break;
        
        // targetPos.x
        case 'B':
            points[accessPoint].targetPos.x = atof(&buffer[2]);
            break;
            
        // targetPos.y
        case 'C':
            points[accessPoint].targetPos.y = atof(&buffer[2]);
            break;
            
        // targetPos.w
        case 'D':
            points[accessPoint].targetPos.w = atof(&buffer[2]);
            break;
            
        // tolerance.x
        case 'E':
            points[accessPoint].tolerance.x = atof(&buffer[2]);
            break;
            
        // tolerance.x
        case 'F':
            points[accessPoint].tolerance.y = atof(&buffer[2]);
            break;
            
        // tolerance.x
        case 'G':
            points[accessPoint].tolerance.w = atof(&buffer[2]);
            break;
            
        // maxSpeed.x
        case 'H':
            points[accessPoint].maxSpeed.x = atof(&buffer[2]);
            break;
            
        // maxSpeed.x
        case 'I':
            points[accessPoint].maxSpeed.y = atof(&buffer[2]);
            break;
            
        // maxSpeed.x
        case 'J':
            points[accessPoint].maxSpeed.w = atof(&buffer[2]);
            break;
            
        // pidOn
        case 'K':
            int pid = atoi(&buffer[2]);
            if(pid == 1)
                points[accessPoint].pidOn = true;
            else
                points[accessPoint].pidOn = false;
            break;
    }
}
*/

int main()
{
    initPath();
    // Manual mode
    PS4_SERIAL_INIT();
    
    // Interrupt
    motorUpdateTicker.attach(&motorUpdate, UPDATE_RATE);
    //pc.attach(&debugCommand, Serial::RxIrq);

    while (1)
    {
        if (autoMode)
        {
            if(action.curPosIsAvailable())
            {
                curPos = action.getCurPos();
                //pc.printLocation(targetPoint, curPos);
                odomUpdate();
            }
        }
        else
        {
            inverse(-vt, -vnt, -wt);
            motorUpdate();
        }
    }
}


